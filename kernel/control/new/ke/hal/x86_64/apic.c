/*
 * File: apic.c
 *    Controlador APIC.
 *    Arquivo principal do módulo interno do kernel.
 *    APIC - Advanced Programmable Interrupt Controller.
 *   Stuff:
 *       +Discrete APIC.
 *       +Integrated local APICs.
 *       +APIC timer.
 *       +I/O APICs.
 * 2015.
 */
// See:
// hwi/dd/nhid/arch/x86/apic.c
// https://wiki.osdev.org/Symmetric_Multiprocessing
// https://www.cheesecake.org/sac/smp.html


// credits: MP Specification.
// APIC has three interrupt modes.
// 1. PIC Mode — 
// effectively bypasses all APIC components and 
// forces the system to operate in single-processor mode.
// 2. Virtual Wire Mode — 
// uses an APIC as a virtual wire, 
// but otherwise operates the same as PIC Mode.
// 3. Symmetric I/O Mode — 
// enables the system to operate with more than one processor.
// Interrupt mode configuration register (IMCR). 
// This register controls whether the interrupt signals 
// that reach the BSP come from the master PIC or 
// from the local APIC.
// In this mode, I/O interrupts are generated by the I/O APIC. 
// All 8259 interrupt lines are either masked or 
// work together with the I/O APIC in a mixed mode.
// Before entering Symmetric I/O Mode, 
// either the BIOS or the operating system 
// must switch out of PIC Mode by changing the IMCR.
// In general, the operating system must use 
// the STARTUP IPI to wake up application processors in
// systems with integrated APICs, 
// but must use INIT IPI in systems with the 82489DX APIC.

// When the system is operated in Symmetric I/O Mode, 
// the operating system may enable the
// LINTIN0 and LINTIN1 of any or all local APICs as necessary.

#include <kernel.h>


//
// == private functions: prototypes =====================
//

static unsigned int local_apic_read_command(unsigned short addr);
static void local_apic_write_command(unsigned short addr,unsigned int val);

//#test
static unsigned int local_apic_get_id(void);
static unsigned int local_apic_get_version(void);

// apic stuffs for x86.
static inline void imcr_pic_to_apic (void);
static inline void imcr_apic_to_pic (void);

// =====================

/* Flush caches */
/*
void flush_cashes(void)
{
	__asm__("wbinvd");
}
*/


//@todo: definir porta 70h usada nesse arquivo.

static unsigned int local_apic_read_command(unsigned short addr)
{
    if( (void *) LAPIC.lapic_va == NULL ){
        panic("local_apic_read_command: LAPIC.lapic_va\n");
    }

// #todo
// Review this method.
    return *( (volatile unsigned int *)(LAPIC.lapic_va + addr));
}

static void local_apic_write_command(unsigned short addr,unsigned int val)
{
    if( (void *) LAPIC.lapic_va == NULL ){
        panic("local_apic_write_command: LAPIC.lapic_va\n");
    }

// #good
    *( (volatile unsigned int *)(LAPIC.lapic_va + addr)) = val;
}


//#test
static unsigned int local_apic_get_id(void)
{
// bits 24~31 for pentium 4 and later.
    return (unsigned int) (local_apic_read_command(LAPIC_APIC_ID) >> 24) & 0xFF;
}

//#test
static unsigned int local_apic_get_version(void)
{
// bits: 0~7 for Integrated APIC.
// 10H~15H
    return (unsigned int) (local_apic_read_command(LAPIC_APIC_VERSION) & 0xFF);
}


// =========


/*
 * imcr_pic_to_apic:
 * Handle interrupt mode configuration register (IMCR).
 * This register controls whether the interrupt signals that reach 
 * the BSP come from the master PIC or from the local APIC. 
 * Before entering Symmetric I/O Mode, either the BIOS or 
 * the operating system must switch out of PIC Mode by changing the IMCR.
 */

/*
The IMCR is supported by two read/writable or write-only I/O ports, 22h and 23h, which receive
address and data respectively. To access the IMCR, write a value of 70h to I/O port 22h, which
selects the IMCR. Then write the data to I/O port 23h. The power-on default value is zero, which
connects the NMI and 8259 INTR lines directly to the BSP. Writing a value of 01h forces the
NMI and 8259 INTR signals to pass through the APIC.
The IMCRP bit of the MP feature
information bytes enables the operating system to detect whether the IMCR is
implemented.
*/

static inline void imcr_pic_to_apic (void)
{
// Select IMCR register.
    out8 ((unsigned short)0x22, (unsigned char) 0x70);
// NMI and 8259 INTR go through APIC. 
    out8 ((unsigned short)0x23, (unsigned char) 0x01);
}


static inline void imcr_apic_to_pic (void)
{
// Select IMCR register.
    out8 ((unsigned short)0x22, (unsigned char) 0x70);
// NMI and 8259 INTR go directly to BSP.
    out8 ((unsigned short)0x23, (unsigned char) 0x00);
}

/*
 creadits: MP Specification
Cache flushing—The processor can generate special flush and 
write-back bus cycles that must be used by external caches 
in a manner that maintains cache coherency. 
The actual responses are implementation-specific and 
may vary from design to design. 
A program can initiate hardware cache flushing by executing a 
WBINVD instruction. This instruction is only guaranteed 
to flush the caches of the local processor.
*/

/*
inline void invalidate_cache_flush(void);
inline void invalidate_cache_flush(void)
{
    asm ("wbinvd");
}
*/

// =================

// #bugbug
// This routine used a lot of hardcoded addresses and a pd entry.
// PAGETABLE_RES5, LAPIC_VA, PD_ENTRY_LAPIC, KERNEL_PD_PA.
void lapic_initializing(unsigned long lapic_pa)
{
    printf("lapic_initializing: \n");

    LAPIC.initialized = FALSE;

// 0xFEE00000
// see: x64gpa.h

    if (lapic_pa != __LAPIC_PA){
        panic("lapic_initializing: lapic_pa\n");
    }

// ===================

// page table
    unsigned long *pt_lapic = (unsigned long *) PAGETABLE_RES5;
// pa
    LAPIC.lapic_pa = (unsigned long) (lapic_pa & 0xFFFFFFFF);
// va
    LAPIC.lapic_va = (unsigned long) LAPIC_VA;
// pagedirectory entry
    LAPIC.entry = (int) PD_ENTRY_LAPIC; 

// Create the table and include the pointer 
// into the kernel page directory.
// ## Estamos passando o ponteiro para o
// diretorio de paginas do kernel.

    mm_fill_page_table( 
      (unsigned long) KERNEL_PD_PA,    // pd 
      (int) PD_ENTRY_LAPIC,            // entry
      (unsigned long) &pt_lapic[0],    // pt
      (unsigned long) (lapic_pa & 0xFFFFFFFF),    // region base (pa)
      (unsigned long) ( PAGE_WRITE | PAGE_PRESENT ) );  // flags=3

//==========================================

// flush tlb
// #bugbug
// Maybe we need to call a method for that.

    asm ("movq %cr3, %rax");
    asm ("movq %rax, %cr3");

//=====================================
	// Destination Format Register (DFR)
	// Value after reset, flat mode
	// depois de invalidar o pic?
	//*(volatile unsigned int*)(LAPIC.lapic_va + ?) = 0xFFFFFFFF; 

	// Logical Destination Register (LDR)
	//// All cpus use logical id 1
	//*(volatile unsigned int*)(LAPIC.lapic_va + ?) = 0x01000000; 

    //*(volatile unsigned int*)(LAPIC.lapic_va + 0x20) = 8;

    // #test
    int localid = (int) local_apic_get_id();
    printf("localid: %d\n",(localid & 0xFF));

    // #test
    // 8bits
    // 10H~15H
    int localversion = (int) local_apic_get_version();
    printf("localversion: %xH\n", (localversion & 0xFF));

    LAPIC.initialized = TRUE;
}



//
// ======================================================
//


// #todo
// Testando um código encontrado em https://wiki.osdev.org/APIC.
// setting up the APIC: 
 
 
/* 
 * check_apic:
 *     returns a 'true' value if the CPU supports APIC
 *  and if the local APIC hasn't been disabled in MSRs
 *  note that this requires CPUID to be supported.
 */

// #todo: Change function name.
// See: cpuid.h

int has_apic (void)
{
   unsigned int eax=0;
   unsigned int ebx=0;
   unsigned int ecx=0;
   unsigned int edx=0;

// #bugbug
// Do we have cpuid support?

   cpuid( 1, eax, ebx, ecx, edx );

   return (int) (edx & CPUID_FEAT_EDX_APIC);
}


/* Set the physical address for local APIC registers */
// ??
// Is it possible to change the base?
// But we have a default adddress, it is 0xFEE00000.

void cpu_set_apic_base(unsigned long apic) 
{
   unsigned int edx=0;
   unsigned int eax = 
       (unsigned int) (apic & 0xfffff000) | IA32_APIC_BASE_MSR_ENABLE;

//#ifdef __PHYSICAL_MEMORY_EXTENSION__
//   edx = (apic >> 32) & 0x0f;
//#endif
 
   cpuSetMSR (
       (unsigned int) IA32_APIC_BASE_MSR, 
       (unsigned int) eax, 
       (unsigned int) edx );
}

 
/*
 * Get the physical address of the APIC registers page
 * make sure you map it to virtual memory ;)
 */
unsigned long cpu_get_apic_base (void) 
{
    unsigned int eax=0;
    unsigned int edx=0;

    cpuGetMSR(
        (unsigned int) IA32_APIC_BASE_MSR, 
        (unsigned int) &eax, 
        (unsigned int) &edx );

/* 
#ifdef __PHYSICAL_MEMORY_EXTENSION__
   return (eax & 0xfffff000) | ((edx & 0x0f) << 32);
#else
   return (eax & 0xfffff000);
#endif
*/

    return (unsigned long) (eax & 0xfffff000);
}


// #todo: 
/* 
void enable_apic(void); 
void enable_apic (void){
    //Hardware enable the Local APIC if it wasn't enabled.
    cpu_set_apic_base ( cpu_get_apic_base() );
 
    // ??
    //Set the Spurious Interrupt Vector Register bit 8 to start receiving interrupts.
    write_reg (0xF0, ReadRegister(0xF0) | 0x100);
}
*/


//
// IO APIC Configuration 
//


/*
uint32_t cpuReadIoApic(void *ioapicaddr, uint32_t reg);
uint32_t cpuReadIoApic(void *ioapicaddr, uint32_t reg)
{
   uint32_t volatile *ioapic = (uint32_t volatile *)ioapicaddr;
   ioapic[0] = (reg & 0xff);
   return ioapic[4];
}
*/
 
/* 
void cpuWriteIoApic(void *ioapicaddr, uint32_t reg, uint32_t value); 
void cpuWriteIoApic(void *ioapicaddr, uint32_t reg, uint32_t value)
{
   uint32_t volatile *ioapic = (uint32_t volatile *)ioapicaddr;
   ioapic[0] = (reg & 0xff);
   ioapic[4] = value;
}
*/


/*
 # SIPI Sequence 
 
void APIC::wakeupSequence(U32 apicId, U8 pvect);
void APIC::wakeupSequence(U32 apicId, U8 pvect)
{
                ICRHigh hreg = {
				.destField = apicId
		};
 
		ICRLow lreg(DeliveryMode::INIT, Level::Deassert, TriggerMode::Edge);
 
		xAPICDriver::write(APIC_REGISTER_ICR_HIGH, hreg.value);
		xAPICDriver::write(APIC_REGISTER_ICR_LOW, lreg.value);
 
		lreg.vectorNo = pvect;
		lreg.delvMode = DeliveryMode::StartUp;
 
		Dbg("APBoot: Wakeup sequence following...");
 
		xAPICDriver::write(APIC_REGISTER_ICR_HIGH, hreg.value);
		xAPICDriver::write(APIC_REGISTER_ICR_LOW, lreg.value);
}
*/ 
 
// NOTE: ICRLow and ICRHigh are types in the Silcos kernel. If your code uses direct bit
// manipulations you must replace some code with bit operations.


//
// end ======================================================
//



/*
uint32_t apic_read(void* apic_base, uint32_t register);
uint32_t apic_read(void* apic_base, uint32_t register) 
{
    return *((volatile uint32_t*)(apic_base + register));
}
*/


/*
void apic_write(void* apic_base, uint32_t register, uint32_t data);
void apic_write(void* apic_base, uint32_t register, uint32_t data) 
{
    *((volatile uint32_t*)(apic_base + register)) = data;
}
*/


//
// End.
//

